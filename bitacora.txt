
Carlos Andres angola berrio - 1118201113
Juan Jose Espinosa Mendez - 1054538340
Se esta construyendo  la gramatica para el compilador PL0 construido en BNF 


Componentes Terminales

    number: Representa un número en el lenguaje. Puede ser un entero o un número de punto flotante. Los números enteros consisten en una o más cifras, mientras que los números de punto flotante tienen un punto decimal seguido de una o más cifras decimales.

    name: Representa un identificador en el lenguaje. Puede consistir en una o más letras (mayúsculas o minúsculas).

    literal: Representa una secuencia de caracteres que puede ser cualquier cosa (.*). Esto parece ser un valor arbitrario que se imprime tal cual.

    relation: Representa expresiones relacionales que pueden comparar dos expresiones. Incluye operadores como >, <, >=, <=, == y !=.

    exprlist: Aparentemente, se define como una lista de expresiones separadas por comas, pero la definición está en blanco.

    relaciones: Define expresiones relacionales, como operaciones and, or y not en relaciones.

Componentes No Terminales

La gramática también incluye varios componentes no terminales que se refieren a estructuras y operaciones específicas del lenguaje de programación:

    statement: Representa una instrucción en el lenguaje. Incluye declaraciones de bucles, condicionales, asignaciones, impresiones, lecturas, retornos, llamadas a funciones, sentencias "skip", operaciones de expresiones y el bloque "begin...end".

    asignamt: Define asignaciones de variables o arreglos.

    relation: Define relaciones entre expresiones. Pueden ser operaciones relacionales como mayor que, menor que, igual a, etc.

    expr: Define expresiones matemáticas y lógicas que involucran números, variables, operadores y llamadas a funciones.
-------------------------------------------------------------------
CLASE 21/09/23
Se comenzó a realizar el analizador lexico basandonos en el analizador lexico para el lenguaje BASIC Darmounth 64 - baslex .py
Ya luego mirando la gramatica que ya habiamos realizado empezamos a identificar los tokens, y los especificamos.  

CLASE 26/09/23
Verificamos que no nos faltara nigun token
Tomamos un ejemplo de un programa que estaba en el archivo de especificaciones, lo llamamos programa.txt 
Con el programa comenzamos a verificar que se estuvieran tomando adecuadamente los tokens
Nos dimos cuenta que no estaba tomando bien los tokens, ya que "done" que era un identificador lo estaba tomando primero
como token DO y el "ne" como name, tendria que tomar "done" completo como name, para solucionar esto agregamso \b para establecer
el limite del token, con esto solucionamos ese problema

CLASE 28/09/23
Se modifico el analizador lexico para agregarle que ignore comentarios comenterios,y comience a detectar errores
de tipo comentario/string no terminado, tambien cuando escribe mal un numero. 
Tambien se agrego el error de que el identificador no puede empezar con un numero y se modifico la expresion regular
porque el identificador puede tener _
Se modifico la forma en que se muestra los tokens, ahora lo hace mediante una tabla  

CLASE 05/09/23
Se agregaron errores que de string no terminado, se comenzó a mirar la estructura del parser.
Se agrego que si se encontraban dos string en una misma linea "Hola" "Mundo", las concatenara "HolaMundo"

CLASE 12/09/23
Comparamos nuestra gramatica con la gramatica del profesor, y corregimos unos erorres

CLASE 19/09/23
Comenzamos a describir las reglas en el parser y a describir los nodos necesarios

CLASE 26/09/23
Se solucionaron y se hicieron cambios en el parser para que se pudiera ejecutar. 
El parser se probó con todos los test2. No ejecutó los ejemplos de big----.pl0 porque arrojaba un error de que excedia la recursividad.
Se agregó que pueda detectar errores
Clase 2/11/23:

Se implementó un método para imprimir el árbol AST, sin embargo, la estructura actual no cumple con los requisitos especificados en las instrucciones del proyecto. 
Se debe trabajar para que la salida del árbol refleje los niveles adecuados de indentación para representar las relaciones padre-hijo entre nodos. Esto mejorará la legibilidad del árbol impreso.

Clase 9/11/23:

Se realizaron avances en la funcionalidad semántica del compilador. 
Se crearon las clases base para el chequeo semántico, incluyendo la clase Checker que hereda de Visitor para recorrer el AST, y la clase SymbolTable para llevar un registro de los símbolos y scopes. 
También se agregaron métodos iniciales en la clase Checker para los nodos AST. Sin embargo, el código agregado aún no ha sido probado o depurado apropiadamente. 
Se debe completar la implementación y comenzar con pruebas incrementales.

Clase 11/11/23:

Se finalizó la implementación inicial de la funcionalidad semántica, completando los métodos faltantes en la clase Checker para recorrer y analizar los distintos nodos del AST. 
Además, se realizaron pruebas utilizando los ejercicios provistos en la carpeta de test3, validando que las reglas semánticas se aplican correctamente y se lanzen errores cuando corresponde.
Se identificaron y corrigieron algunos errores durante las pruebas. Queda pendiente aumentar la cobertura de pruebas e identificar posibles casos borde que aún no estén contemplados apropiadamente.

